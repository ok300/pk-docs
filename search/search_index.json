{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Pubky SDK","text":"<p>Pubky is an open protocol for per-public-key backends for censorship resistant web applications. It combines PKARR (a censorship resistant public-key based alternative to DNS) with conventional web technologies to keep users in control of their identities and data.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Public key based authentication: Users authenticate using their keypairs</li> <li>Key-value storage: Store and retrieve data through PUT/GET/DELETE HTTP operations</li> <li>Decentralized: Data is stored on homeservers but indexed via PKARR</li> <li>Censorship resistant: Built on top of DHT and PKARR for resilience</li> </ul>"},{"location":"01_get_started/","title":"Get Started","text":""},{"location":"01_get_started/#add-dependency","title":"Add Dependency","text":"<p>Add the dependency for <code>pubky</code> to your project's <code>Cargo.toml</code>:</p> <pre><code>pubky = { version = \"0.6.0-rc.6\" }\n</code></pre> <p>Note: Pubky internally uses PKARR for public key resolution and discovery.</p>"},{"location":"02_init_client/","title":"Initialize Client","text":"<p>To interact with Pubky homeservers, you need to create a <code>Pubky</code> instance. The <code>Pubky</code> facade is the main entry point for the SDK and owns the transport layer.</p>"},{"location":"02_init_client/#basic-client","title":"Basic Client","text":"<pre><code>fn init_client() -&gt; pubky::Result&lt;Pubky&gt; {\n    let pubky = Pubky::new()?;\n    Ok(pubky)\n}\n</code></pre>"},{"location":"02_init_client/#testnet-mode","title":"Testnet Mode","text":"<p>For development and testing, you can use testnet mode which connects to test homeservers:</p> <pre><code>fn init_client_testnet() -&gt; pubky::Result&lt;Pubky&gt; {\n    // Create a client configured for testnet mode\n    let pubky = Pubky::testnet()?;\n    Ok(pubky)\n}\n</code></pre> <p>The testnet mode is useful for development without affecting production data or requiring production homeserver access.</p>"},{"location":"03_storage_api/","title":"Storage API","text":"<p>The Pubky SDK provides two ways to access storage: public (read-only) and authenticated.</p>"},{"location":"03_storage_api/#public-storage-read-only","title":"Public Storage (Read-Only)","text":"<p>Public storage allows you to read publicly accessible data from any user without authentication.</p> <pre><code>async fn storage_public() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // Get the public storage accessor\n    let public = pubky.public_storage();\n\n    // The public key of the user whose data you want to access\n    let user_pubkey = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid user public key\");\n\n    // Read a file\n    let file = public\n        .get(format!(\"pubky://{}/pub/acme.app/file.txt\", user_pubkey))\n        .await?\n        .bytes()\n        .await?;\n    println!(\"Retrieved file: {:?}\", file);\n\n    // List directory entries with limit\n    let entries = public\n        .list(format!(\"pubky://{}/pub/acme.app/\", user_pubkey))?\n        .limit(10)\n        .send()\n        .await?;\n\n    for entry in entries {\n        println!(\"Entry: {}\", entry.to_pubky_url());\n    }\n\n    Ok(())\n}\n</code></pre> <p>Key features:</p> <ul> <li>Uses addressed format like <code>\"pubky://&lt;user&gt;/pub/app/file.txt\"</code></li> <li>No authentication required</li> <li>Read-only access</li> <li>Can list directory contents with pagination</li> <li>Works with any user's public data</li> </ul> <p>Convention: Store your app's public data under a domain-like folder in <code>/pub</code>, for example <code>/pub/mycoolnew.app/</code>.</p>"},{"location":"03_storage_api/#session-storage-authenticated","title":"Session Storage (Authenticated)","text":"<p>Session storage allows you to read and write your own data using an authenticated session. This is used when you need to store or modify data on your homeserver.</p> <pre><code>async fn storage_session() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // Sign in to get a session\n    let session = signer.signin().await?;\n\n    // Get the session storage\n    let storage = session.storage();\n\n    // Write data\n    storage\n        .put(\"/pub/my.app/data.txt\", \"Hello from session storage\")\n        .await?;\n\n    // Read data\n    let text = storage.get(\"/pub/my.app/data.txt\").await?.text().await?;\n    println!(\"Retrieved: {}\", text);\n\n    Ok(())\n}\n</code></pre> <p>Key features:</p> <ul> <li>Uses absolute paths like <code>\"/pub/my.app/data.txt\"</code></li> <li>Requires authentication via a <code>PubkySession</code></li> <li>Supports read and write operations</li> <li>All operations are authenticated using your session</li> </ul>"},{"location":"05_pkdns/","title":"PKDNS","text":"<p>PKDNS (Public Key DNS) allows you to resolve and publish <code>_pubky</code> records that map public keys to homeservers.</p>"},{"location":"05_pkdns/#resolve-record","title":"Resolve Record","text":"<p>To resolve a record, you need a <code>PublicKey</code>. The <code>resolve</code> method on the <code>Client</code> will return a <code>SignedPacket</code> if one is found for the given <code>PublicKey</code>.</p> <p>TODO</p>"},{"location":"05_pkdns/#publish-record","title":"Publish Record","text":"<p>To publish a record, you need a <code>Keypair</code> to sign the packet. The <code>publish</code> method on the <code>Client</code> will publish the <code>SignedPacket</code> to the DHT.</p> <p>TODO</p>"},{"location":"05_pkdns/#operations","title":"Operations","text":"<ul> <li>Resolve another user's homeserver: Use <code>pubky.get_homeserver_of(&amp;user_id)</code> to find where a user's data is hosted</li> <li>Publish your homeserver (if stale): Use <code>pkdns().publish_homeserver_if_stale(None)</code> to update your record only when needed</li> <li>Force republish: Use <code>pkdns().publish_homeserver_force(Some(&amp;new_homeserver))</code> when migrating to a new homeserver</li> <li>Fetch your own record: Use <code>pkdns().get_homeserver()</code> to retrieve your current homeserver information</li> </ul> <p>The homeserver record is published via PKARR and cached by the DHT, allowing other users to discover where your data is stored.</p>"},{"location":"09_pkdns_tls/","title":"PKDNS TLS","text":"<p>PKDNS TLS (Public Key DNS over TLS) provides a secure DNS-over-TLS service for resolving PKARR records. It allows clients to query DNS records using TLS-encrypted connections and enables servers to host PKDNS services.</p>"},{"location":"09_pkdns_tls/#connecting-to-a-pkdns-tls-endpoint","title":"Connecting to a PKDNS TLS Endpoint","text":"<p>To connect to a PKDNS TLS endpoint, you can use a Pkarr public key as the URL with <code>reqwest</code>. The PKARR client integration with <code>reqwest</code> automatically handles the DNS resolution and TLS connection.</p> <p>TODO</p> <p>This example demonstrates:</p> <ul> <li>Using a Pkarr public key as a URL (e.g., <code>https://&lt;public_key&gt;/</code>)</li> <li>Creating a <code>reqwest</code> client with PKDNS TLS support using the PKARR client</li> <li>Making HTTP requests over the TLS-secured connection to the Pkarr domain</li> </ul>"},{"location":"09_pkdns_tls/#serving-a-pkdns-tls-service","title":"Serving a PKDNS TLS Service","text":"<p>To serve your own PKDNS TLS service, you can run an HTTP server with TLS using your keypair and publish the server information to the DHT. This makes your service accessible via its public key.</p> <p>TODO</p> <p>This example demonstrates:</p> <ul> <li>Generating a keypair for the server identity</li> <li>Publishing server DNS records (HTTPS SVCB and address records) to the DHT</li> <li>Running an HTTPS server with TLS using the keypair's self-signed certificate</li> <li>Making the service accessible via <code>https://&lt;public_key&gt;/</code></li> </ul> <p>Note</p> <p>When deploying a PKDNS TLS service in production, ensure you:</p> <ul> <li>Republish the DNS records periodically (recommended: every hour) and when the server address changes</li> <li>Use a public IP address if you want the service to be accessible from other networks</li> <li>Configure appropriate timeout and connection limits</li> <li>Implement rate limiting to prevent abuse</li> <li>Monitor and log service activity for security and debugging</li> </ul>"},{"location":"09_qr_auth/","title":"QR Auth","text":"<p>QR Auth enables keyless authentication for third-party apps. Users can authorize apps by scanning a QR code or clicking a deeplink with their signing device (like Pubky Ring).</p>"},{"location":"09_qr_auth/#authorization-flow","title":"Authorization Flow","text":"<p>The QR auth flow consists of three main steps: building capabilities, getting the authorization URL, and awaiting approval.</p> <pre><code>async fn qr_auth() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // Build capabilities for acme.app\n    let caps = Capabilities::builder()\n        .read_write(\"/pub/acme.app/\")\n        .finish();\n\n    // Start the auth flow\n    let flow = pubky.start_auth_flow(&amp;caps)?;\n\n    // Get the authorization URL to display as QR code or deeplink\n    let auth_url = flow.authorization_url();\n    println!(\"Scan this QR code or open this URL: {}\", auth_url);\n\n    // Await approval from the signing device\n    // (In real usage, this would wait for the user to approve on their device)\n    let _session = flow.await_approval().await?;\n\n    println!(\"Auth approved! Session ready.\");\n\n    Ok(())\n}\n</code></pre>"},{"location":"09_qr_auth/#how-it-works","title":"How It Works","text":"<ol> <li> <p>Build Capabilities: Define what permissions your app needs using <code>Capabilities::builder()</code>. Use methods like <code>read_write()</code> to specify access patterns for your app's routes.</p> </li> <li> <p>Start Auth Flow: Call <code>pubky.start_auth_flow(&amp;caps)</code> to initiate the authorization process. This returns a <code>PubkyAuthFlow</code> object.</p> </li> <li> <p>Get Authorization URL: Use <code>flow.authorization_url()</code> to get a URL that can be displayed as a QR code or sent as a deeplink. Users scan this with their signing device (e.g., Pubky Ring).</p> </li> <li> <p>Await Approval: Call <code>flow.await_approval()</code> to wait for the user to approve the request on their signing device. This returns a <code>PubkySession</code> that's bound to the authorized capabilities.</p> </li> </ol>"},{"location":"09_qr_auth/#typical-usage","title":"Typical Usage","text":"<p>This pattern is ideal for:</p> <ul> <li>Third-party apps that need to access user data</li> <li>Keyless applications where the app doesn't hold the user's private keys</li> <li>Cross-device authentication where users sign in on one device to authorize another</li> </ul> <p>The signing device (like Pubky Ring) holds the user's keys and approves the authorization request, providing the app with a session-bound credential.</p>"},{"location":"02_pubky_app/00_intro/","title":"Pubky App","text":"<p>TODO Data model (<code>pubky-app-specs</code>)</p> <p>TODO Architecture</p> <p>TODO Authentication</p>"},{"location":"03_build_own_app/00_intro/","title":"Build Your Own App","text":"<p>TODO Make use of Pubky Core primitives (tagging, comments, etc)</p> <p>TODO Authentication</p>"},{"location":"04_homeserver_api/03_signup/","title":"Signup","text":"<p>Before you can store data on a homeserver, you need to sign up with that homeserver using your keypair. In Pubky, you first create a <code>PubkySigner</code> from your keypair, then use it to sign up.</p> <pre><code>async fn signup() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // Generate a new keypair for the user\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key (as a string)\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let _session = signer.signup(&amp;homeserver, None).await?;\n\n    println!(\"Successfully signed up to homeserver\");\n\n    Ok(())\n}\n</code></pre> <p>The signup process:</p> <ol> <li>Create a <code>Pubky</code> instance</li> <li>Generate or use an existing keypair</li> <li>Create a <code>PubkySigner</code> from your keypair using <code>pubky.signer(keypair)</code></li> <li>Identify the homeserver you want to use (by its public key)</li> <li>Call <code>signup</code> on the signer with the homeserver's public key</li> <li>Optionally provide a signup code if the homeserver requires one</li> </ol> <p>After successful signup, your public key will be associated with the homeserver and published via PKARR. The signup returns a <code>PubkySession</code> which you can use for authenticated operations.</p>"},{"location":"04_homeserver_api/04_put/","title":"PUT - Store Data","text":"<p>To store data on a homeserver, use the <code>put</code> method on the session's storage. In Pubky, you work with a <code>PubkySession</code> that provides authenticated access.</p> <pre><code>async fn put() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let session = signer.signup(&amp;homeserver, None).await?;\n\n    // The content to store\n    let content = \"Hello, Pubky!\";\n\n    // PUT the content to the homeserver\n    session.storage().put(\"/pub/example.txt\", content).await?;\n\n    println!(\"Successfully stored data\");\n\n    Ok(())\n}\n</code></pre> <p>The PUT operation:</p> <ul> <li>Requires a <code>PubkySession</code> obtained from signing up or signing in</li> <li>Takes a path (not a full URL) relative to your homeserver</li> <li>Accepts data in various formats (strings, bytes, etc.)</li> <li>Creates or overwrites the data at the specified path</li> <li>All operations are authenticated using your session</li> </ul>"},{"location":"04_homeserver_api/05_get/","title":"GET - Retrieve Data","text":"<p>To retrieve data from a homeserver, use the <code>get</code> method on the <code>PublicStorage</code> API. This allows you to read data from any user without authentication.</p> <pre><code>async fn get() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // The public key of the user whose data you want to retrieve\n    let user_pubkey = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid user public key\");\n\n    // The path to the data you want to retrieve\n    let url = format!(\"pubky://{}/pub/example.txt\", user_pubkey);\n\n    // GET the content from the homeserver\n    let response = pubky.public_storage().get(url).await?;\n    let content = response.bytes().await?;\n\n    println!(\"Retrieved content: {:?}\", content);\n\n    Ok(())\n}\n</code></pre> <p>The GET operation:</p> <ul> <li>Uses the <code>public_storage()</code> API from your <code>Pubky</code> instance</li> <li>Takes a <code>pubky://</code> URL that specifies the public key and path</li> <li>Returns the data stored at that location</li> <li>Can read data from any public key (if the data is public)</li> <li>Returns standard HTTP response with bytes</li> </ul>"},{"location":"04_homeserver_api/05_get/#listing-directory-contents","title":"Listing Directory Contents","text":"<p>To list the contents of a directory:</p> <pre><code>async fn list() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // The public key of the user whose data you want to list\n    let user_pubkey = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid user public key\");\n\n    // List contents of a path\n    let url = format!(\"pubky://{}/pub/\", user_pubkey);\n\n    let response = pubky.public_storage().get(url).await?;\n    let listing = response.text().await?;\n\n    println!(\"Directory listing: {}\", listing);\n\n    Ok(())\n}\n</code></pre> <p>Directory listings work the same way - just use a path ending with <code>/</code> to list the contents of that directory.</p>"},{"location":"04_homeserver_api/06_delete/","title":"DELETE - Remove Data","text":"<p>To delete data from a homeserver, use the <code>delete</code> method on the session's storage. Like PUT, this requires an authenticated session.</p> <pre><code>async fn delete() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let session = signer.signup(&amp;homeserver, None).await?;\n\n    // DELETE the content from the homeserver\n    session.storage().delete(\"/pub/example.txt\").await?;\n\n    println!(\"Successfully deleted data\");\n\n    Ok(())\n}\n</code></pre> <p>The DELETE operation:</p> <ul> <li>Requires a <code>PubkySession</code> obtained from signing up or signing in</li> <li>Takes a path (not a full URL) relative to your homeserver</li> <li>Removes the data at the specified location</li> <li>All operations are authenticated using your session</li> <li>Only the owner of the data can delete it</li> </ul>"}]}