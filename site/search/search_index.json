{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Intro","text":"<p>...</p>"},{"location":"00_pkarr/00_intro/","title":"Intro","text":"<p>PKARR / PKDNS / PKTLS intro</p>"},{"location":"00_pkarr/01_get_started/","title":"Get Started","text":""},{"location":"00_pkarr/01_get_started/#add-dependency","title":"Add Dependency","text":"<p>Add the dependencies for <code>pkarr</code> to your project's <code>Cargo.toml</code>:</p> <p>To use both the DHT and relays (recommended): <pre><code>pkarr = { version = \"5.0.0\" }\n</code></pre></p> <p>To use only the DHT: <pre><code>pkarr = { version = \"5.0.0\", default-features = false, features = [\"dht\"] }\n</code></pre></p> <p>To use only relays: <pre><code>pkarr = { version = \"5.0.0\", default-features = false, features = [\"relays\"] }\n</code></pre></p> <p>Note the available feature flags.</p>"},{"location":"00_pkarr/02_init_client/","title":"Initialize Client","text":"<p>To be able to re-use the client's internal caches, it's best practice to use a singleton pattern and store the client instance in an <code>Arc</code>:</p> <pre><code>fn init_client() -&gt; Result&lt;Client, Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder().build()?;\n    Ok(client)\n}\n</code></pre> <p>The client builder allows you to optionally customize the client's behavior. For example, you can configure the cache, add custom relays and bootstrap nodes, and set a custom request timeout:</p> <pre><code>fn init_client_with_opts() -&gt; Result&lt;Client, Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder()\n        // Set a custom cache size.\n        .cache(Arc::new(InMemoryCache::new(5_000.try_into()?)))\n        // Set custom relays.\n        .relays(&amp;[Url::parse(\"https://my-relay.com\")?])?\n        // Set custom bootstrap nodes.\n        .bootstrap(&amp;[\"127.0.0.1:6881\"])\n        // Set a custom request timeout.\n        .request_timeout(Duration::from_secs(10))\n        .build()?;\n\n    Ok(client)\n}\n</code></pre>"},{"location":"00_pkarr/02_init_client/#relays-only-mode","title":"Relays-only Mode","text":"<p>If you're planning to use the client in an environment with no UDP, or behind a NAT, your PKARR client won't be able to directly query the DHT and will instead rely on relays:</p> <pre><code>fn init_client_relays_only() -&gt; Result&lt;Arc&lt;Client&gt;, Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder()\n        // Optionally add custom relays\n        // .relays(&amp;[Url::parse(\"https://a.custom.relay\")?])?\n        .build()?;\n    Ok(Arc::new(client))\n}\n</code></pre> <p>WASM applications fall in this scenario.</p>"},{"location":"00_pkarr/02_init_client/#dht-only-mode","title":"DHT-only Mode","text":"<p>Conversely, if you want your client to exclusively rely on direct DHT queries, you can disable the relays:</p> <pre><code>fn init_client_dht_only() -&gt; Result&lt;Arc&lt;Client&gt;, Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder()\n        .no_relays()\n        // Optionally add custom bootstrap DHT nodes\n        // .bootstrap(vec![\"127.0.0.1:45555\".to_string()])\n        .build()?;\n    Ok(Arc::new(client))\n}\n</code></pre> <p>Note however that direct DHT queries will likely be slower than if relays were enabled as well.</p>"},{"location":"00_pkarr/03_resolve_record/","title":"Resolve Record","text":"<p>To resolve a record, you need a <code>PublicKey</code>. The <code>resolve</code> method on the <code>Client</code> will return a <code>SignedPacket</code> if one is found for the given <code>PublicKey</code>.</p> <pre><code>async fn resolve_record() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder().build()?;\n\n    let pk = \"9fdaa3b3cb04f24328975a4862419d2a2a46639c33659a101f653457a40b9d16\";\n\n    match client.resolve(&amp;pk.parse()?).await {\n        Some(signed_packet) =&gt; println!(\"Resolved packet: {signed_packet:?}\"),\n        None =&gt; println!(\"No record found for the public key\"),\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"00_pkarr/04_publish_record/","title":"Publish Record","text":"<p>To publish a record, you need a <code>Keypair</code> to sign the packet. The <code>publish</code> method on the <code>Client</code> will publish the <code>SignedPacket</code> to the DHT.</p> <pre><code>async fn publish_record() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {\n    let client = Client::builder().build()?;\n\n    // Generate a new keypair.\n    let keypair = Keypair::random();\n\n    // Create a signed packet with a TXT record.\n    let signed_packet = SignedPacket::builder()\n        .txt(\"_proto\".try_into()?, \"foo=bar\".try_into()?, 30)\n        .build(&amp;keypair)?;\n\n    match client.publish(&amp;signed_packet, None).await {\n        Ok(()) =&gt; println!(\"Published successfully!\"),\n        Err(e) =&gt; println!(\"Failed to publish: {e}\"),\n    }\n\n    Ok(())\n}\n</code></pre>"},{"location":"01_pubky_client/00_intro/","title":"Pubky Client","text":"<p>TODO Usage, examples</p>"},{"location":"02_pubky_app/00_intro/","title":"Pubky App","text":"<p>TODO Data model (<code>pubky-app-specs</code>)</p> <p>TODO Architecture</p> <p>TODO Authentication</p>"},{"location":"03_build_own_app/00_intro/","title":"Build Your Own App","text":"<p>TODO Make use of Pubky Core primitives (tagging, comments, etc)</p> <p>TODO Authentication</p>"},{"location":"04_pubky/00_intro/","title":"Pubky","text":"<p>Pubky is an open protocol for per-public-key backends for censorship resistant web applications. It combines PKARR (a censorship resistant public-key based alternative to DNS) with conventional web technologies to keep users in control of their identities and data.</p>"},{"location":"04_pubky/00_intro/#key-features","title":"Key Features","text":"<ul> <li>Public key based authentication: Users authenticate using their keypairs</li> <li>Key-value storage: Store and retrieve data through PUT/GET/DELETE HTTP operations</li> <li>Decentralized: Data is stored on homeservers but indexed via PKARR</li> <li>Censorship resistant: Built on top of DHT and PKARR for resilience</li> </ul>"},{"location":"04_pubky/01_get_started/","title":"Get Started","text":""},{"location":"04_pubky/01_get_started/#add-dependency","title":"Add Dependency","text":"<p>Add the dependency for <code>pubky</code> to your project's <code>Cargo.toml</code>:</p> <pre><code>pubky = { version = \"0.6.0-rc.6\" }\n</code></pre> <p>Note: Pubky internally uses PKARR for public key resolution and discovery.</p>"},{"location":"04_pubky/02_init_client/","title":"Initialize Client","text":"<p>To interact with Pubky homeservers, you need to create a <code>Pubky</code> instance. The <code>Pubky</code> facade is the main entry point for the SDK and owns the transport layer.</p>"},{"location":"04_pubky/02_init_client/#basic-client","title":"Basic Client","text":"<pre><code>fn init_client() -&gt; pubky::Result&lt;Pubky&gt; {\n    let pubky = Pubky::new()?;\n    Ok(pubky)\n}\n</code></pre>"},{"location":"04_pubky/02_init_client/#testnet-mode","title":"Testnet Mode","text":"<p>For development and testing, you can use testnet mode which connects to test homeservers:</p> <pre><code>fn init_client_testnet() -&gt; pubky::Result&lt;Pubky&gt; {\n    // Create a client configured for testnet mode\n    let pubky = Pubky::testnet()?;\n    Ok(pubky)\n}\n</code></pre> <p>The testnet mode is useful for development without affecting production data or requiring production homeserver access.</p>"},{"location":"04_pubky/03_signup/","title":"Signup","text":"<p>Before you can store data on a homeserver, you need to sign up with that homeserver using your keypair. In Pubky v0.6.0-rc.6, you first create a <code>PubkySigner</code> from your keypair, then use it to sign up.</p> <pre><code>async fn signup() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // Generate a new keypair for the user\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key (as a string)\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let _session = signer.signup(&amp;homeserver, None).await?;\n\n    println!(\"Successfully signed up to homeserver\");\n\n    Ok(())\n}\n</code></pre> <p>The signup process:</p> <ol> <li>Create a <code>Pubky</code> instance</li> <li>Generate or use an existing keypair</li> <li>Create a <code>PubkySigner</code> from your keypair using <code>pubky.signer(keypair)</code></li> <li>Identify the homeserver you want to use (by its public key)</li> <li>Call <code>signup</code> on the signer with the homeserver's public key</li> <li>Optionally provide a signup code if the homeserver requires one</li> </ol> <p>After successful signup, your public key will be associated with the homeserver and published via PKARR. The signup returns a <code>PubkySession</code> which you can use for authenticated operations.</p>"},{"location":"04_pubky/04_put/","title":"PUT - Store Data","text":"<p>To store data on a homeserver, use the <code>put</code> method on the session's storage. In Pubky v0.6.0-rc.6, you work with a <code>PubkySession</code> that provides authenticated access.</p> <pre><code>async fn put() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let session = signer.signup(&amp;homeserver, None).await?;\n\n    // The content to store\n    let content = \"Hello, Pubky!\";\n\n    // PUT the content to the homeserver\n    session.storage().put(\"/pub/example.txt\", content).await?;\n\n    println!(\"Successfully stored data\");\n\n    Ok(())\n}\n</code></pre> <p>The PUT operation:</p> <ul> <li>Requires a <code>PubkySession</code> obtained from signing up or signing in</li> <li>Takes a path (not a full URL) relative to your homeserver</li> <li>Accepts data in various formats (strings, bytes, etc.)</li> <li>Creates or overwrites the data at the specified path</li> <li>All operations are authenticated using your session</li> </ul>"},{"location":"04_pubky/05_get/","title":"GET - Retrieve Data","text":"<p>To retrieve data from a homeserver, use the <code>get</code> method on the <code>PublicStorage</code> API. This allows you to read data from any user without authentication.</p> <pre><code>async fn get() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // The public key of the user whose data you want to retrieve\n    let user_pubkey = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid user public key\");\n\n    // The path to the data you want to retrieve\n    let url = format!(\"pubky://{}/pub/example.txt\", user_pubkey);\n\n    // GET the content from the homeserver\n    let response = pubky.public_storage().get(url).await?;\n    let content = response.bytes().await?;\n\n    println!(\"Retrieved content: {:?}\", content);\n\n    Ok(())\n}\n</code></pre> <p>The GET operation:</p> <ul> <li>Uses the <code>public_storage()</code> API from your <code>Pubky</code> instance</li> <li>Takes a <code>pubky://</code> URL that specifies the public key and path</li> <li>Returns the data stored at that location</li> <li>Can read data from any public key (if the data is public)</li> <li>Returns standard HTTP response with bytes</li> </ul>"},{"location":"04_pubky/05_get/#listing-directory-contents","title":"Listing Directory Contents","text":"<p>To list the contents of a directory:</p> <pre><code>async fn list() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n\n    // The public key of the user whose data you want to list\n    let user_pubkey = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid user public key\");\n\n    // List contents of a path\n    let url = format!(\"pubky://{}/pub/\", user_pubkey);\n\n    let response = pubky.public_storage().get(url).await?;\n    let listing = response.text().await?;\n\n    println!(\"Directory listing: {}\", listing);\n\n    Ok(())\n}\n</code></pre> <p>Directory listings work the same way - just use a path ending with <code>/</code> to list the contents of that directory.</p>"},{"location":"04_pubky/06_delete/","title":"DELETE - Remove Data","text":"<p>To delete data from a homeserver, use the <code>delete</code> method on the session's storage. Like PUT, this requires an authenticated session.</p> <pre><code>async fn delete() -&gt; pubky::Result&lt;()&gt; {\n    let pubky = Pubky::new()?;\n    let keypair = Keypair::random();\n    let signer = pubky.signer(keypair);\n\n    // The homeserver's public key\n    let homeserver = PublicKey::try_from(\"o4dksfbqk85ogzdb5osziw6befigbuxmuxkuxq8434q89uj56uyy\")\n        .expect(\"Valid homeserver public key\");\n\n    // Sign up to the homeserver\n    let session = signer.signup(&amp;homeserver, None).await?;\n\n    // DELETE the content from the homeserver\n    session.storage().delete(\"/pub/example.txt\").await?;\n\n    println!(\"Successfully deleted data\");\n\n    Ok(())\n}\n</code></pre> <p>The DELETE operation:</p> <ul> <li>Requires a <code>PubkySession</code> obtained from signing up or signing in</li> <li>Takes a path (not a full URL) relative to your homeserver</li> <li>Removes the data at the specified location</li> <li>All operations are authenticated using your session</li> <li>Only the owner of the data can delete it</li> </ul>"}]}